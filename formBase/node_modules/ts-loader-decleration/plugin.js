"use strict";
exports.__esModule = true;
var path = require("path");
var esprima = require("esprima");
var beautify = require("js-beautify");
var DeclerationsPlugin = /** @class */ (function () {
    function DeclerationsPlugin(options) {
        if (options === void 0) { options = {}; }
        this.out = options.out || './bundle.d.ts';
        this.main = options.main;
        this.fs = options.fs || require('fs');
    }
    DeclerationsPlugin.prototype.apply = function (compiler) {
        var _this = this;
        //Wait for compiler to emit files
        compiler.plugin('done', function (stats) {
            //Detect which out exists
            var main = _this.main;
            if (main) {
                if (typeof stats.compilation.options.entry !== 'string' && typeof stats.compilation.options.entry[main] === 'string') {
                    main = path.join(stats.compilation.options.output.path, stats.compilation.options.entry[main].replace('.ts', '.d.ts'));
                }
                else {
                    main = path.join(stats.compilation.options.output.path, _this.main);
                }
            }
            else {
                if (typeof stats.compilation.options.entry !== 'string') {
                    throw new Error('TSLoaderDecleration: Must specify main option when using multiple entry points.');
                }
                else {
                    main = path.join(stats.compilation.options.output.path, stats.compilation.options.entry.replace('.ts', '.d.ts'));
                    if (!_this.fs.existsSync(main)) {
                        main = path.join(stats.compilation.options.output.path, stats.compilation.options.output.filename.replace('.js', '.d.ts'));
                    }
                }
            }
            //End now if build failed
            if (!_this.fs.existsSync(main)) {
                return;
            }
            //Create shared bundle and remove old source files
            var out = path.join(stats.compilation.options.output.path, _this.out);
            var options = {
                name: 'Module',
                out: out,
                main: main,
                removeSource: true,
                emitOnIncludedFileNotFound: true,
                emitOnNoIncludedFileNotFound: true,
                outputAsModuleFolder: true
            };
            //Generate merged bundles
            try {
                if (_this.fs) {
                    require('proxyquire').noCallThru()('dts-bundle/lib/index.js', { fs: _this.fs }).bundle(options);
                }
                else {
                    require('dts-bundle').bundle(options);
                }
            }
            catch (err) {
                console.error(err);
                return;
            }
            //Remove source directory
            //rimraf.sync(path.join(stats.compilation.options.output.path, path.dirname(stats.compilation.options.entry)))
            //Read decleration bundle from file
            var bundle = _this.fs.readFileSync(out).toString();
            //Remove temporary values
            bundle = bundle.split('\n').filter(function (line) {
                return !line.startsWith('import \'./') && !line.startsWith('import \'../') && !line.startsWith('import \"./') && !line.startsWith('import \"../');
            }).join('\n');
            //Use current bundle if no modules found
            if (bundle.indexOf('declare module \'') <= -1) {
                _this.fs.writeFileSync(out, bundle);
                return;
            }
            //Prepare working variables
            var newBundle = '';
            var imports = {};
            var exports = [];
            var externals = {};
            //Loop through each trimmed module
            var subBundles = bundle.split('declare module \'');
            subBundles.shift();
            for (var _i = 0, subBundles_1 = subBundles; _i < subBundles_1.length; _i++) {
                var segment = subBundles_1[_i];
                var module_1 = segment.trim();
                var name_1 = module_1.substring(0, module_1.indexOf("'"));
                //Check whether module is entry
                if (name_1 === 'Module') {
                    //Prepare temp variables
                    var tempImports_1 = [];
                    var tempExports = [];
                    var importing_1 = false;
                    var exporting = false;
                    var exportingFile = false;
                    var exportingAll = false;
                    var filename_1 = false;
                    var start = 0;
                    var offset = 1;
                    var first = false;
                    //Loop through each token in module
                    var tokens = esprima.tokenize("'" + module_1, { range: true });
                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        var nextToken = tokens.length >= i + 1 ? tokens[i + 1] : undefined;
                        //Start importing
                        if (token.type === 'Keyword' && token.value === 'import') {
                            importing_1 = true;
                            tempImports_1 = [];
                            start = token.range[0];
                        }
                        //Append import
                        if (importing_1 && token.type === 'Identifier' && token.value !== 'from') {
                            tempImports_1.push(token.value);
                        }
                        //Look for import filename
                        if (importing_1 && token.value === 'from') {
                            filename_1 = true;
                        }
                        if (importing_1 && filename_1 && token.type === 'String') {
                            importing_1 = false;
                            filename_1 = false;
                            //Merge or leave value if star
                            var name_2 = token.value.replace(/\'/g, '');
                            if (imports[name_2] === undefined) {
                                imports[name_2] = [];
                            }
                            if (imports[name_2].indexOf('*') <= -1) {
                                imports[name_2] = imports[name_2].concat(tempImports_1);
                            }
                            //Replace with whitespace
                            module_1 = _this.replace(start - offset, token.range[1] - (offset - 1), module_1);
                            offset += 1;
                        }
                        //Exporting wildcard found
                        if (exporting && token.type === 'Punctuator' && token.value === '*') {
                            exportingAll = true;
                        }
                        //Stop exporting type found
                        if (exporting && token.type === 'Keyword') {
                            exporting = false;
                        }
                        //Start exporting
                        if (token.type === 'Keyword' && token.value === 'export') {
                            exporting = true;
                            tempExports = [];
                            start = token.range[0];
                        }
                        //Append export
                        if (exporting && !exportingAll && token.type === 'Identifier') {
                            exports.push(token.value);
                            tempExports.push(token.value);
                        }
                        //Stop exporting
                        if (exporting && token.type === 'Punctuator' && token.value === '}') {
                            exporting = false;
                            //Check whether export ended
                            if (nextToken && nextToken.type === 'Identifier' && nextToken.value === 'from') {
                                exportingFile = true;
                            }
                            else {
                                //Replace with whitespace
                                module_1 = _this.replace(start - offset, token.range[1] - (offset - 1), module_1);
                                offset += 1;
                            }
                        }
                        //Stop exporting file
                        if ((exportingFile || exportingAll) && token.type === 'String') {
                            //Merge or leave value if star
                            var name_3 = token.value.replace(/\'/g, '');
                            if (imports[name_3] === undefined) {
                                imports[name_3] = [];
                            }
                            if (exportingAll) {
                                imports[name_3] = ['*'];
                            }
                            else if (imports[name_3].indexOf('*') <= -1) {
                                imports[name_3] = imports[name_3].concat(tempExports);
                            }
                            //Reset vars
                            exportingFile = false;
                            exportingAll = false;
                            //Replace with whitespace
                            module_1 = _this.replace(start - offset, token.range[1] - (offset - 1), module_1);
                            offset += 1;
                        }
                    }
                    //Remove module wrapper and add to buffer
                    module_1 = _this.replace(0, module_1.indexOf('{') + 1, module_1);
                    module_1 = _this.replace(module_1.lastIndexOf('}'), module_1.length, module_1);
                    newBundle += module_1;
                }
                //Check whether name exists in imports
                if (!imports.hasOwnProperty(name_1)) {
                    continue;
                }
                //Loop through and extract external exports
                var tempImports = [];
                var importing = false;
                var filename = true;
                for (var _a = 0, _b = esprima.tokenize("'" + module_1); _a < _b.length; _a++) {
                    var token = _b[_a];
                    //Start importing
                    if (token.type === 'Keyword' && token.value === 'import') {
                        importing = true;
                        tempImports = [];
                    }
                    //Append import
                    if (importing && token.type === 'Identifier' && token.value !== 'from') {
                        tempImports.push(token.value);
                    }
                    //Look for import filename
                    if (importing && token.value === 'from') {
                        filename = true;
                    }
                    if (importing && filename && token.type === 'String') {
                        importing = false;
                        filename = false;
                        //Add imports to externals
                        var name_4 = token.value.replace(/\'/g, '');
                        //Check whether internal or external
                        if (name_4.startsWith('Module/')) {
                            //Add to imports
                            if (imports[name_4].indexOf('*') <= -1) {
                                imports[name_4] = tempImports;
                            }
                        }
                        else {
                            //Create externals category
                            if (!externals.hasOwnProperty(name_4)) {
                                externals[name_4] = [];
                            }
                            //Add imports to externals category if not existing
                            for (var _c = 0, tempImports_2 = tempImports; _c < tempImports_2.length; _c++) {
                                var imprt = tempImports_2[_c];
                                if (externals[name_4].indexOf(imprt) <= -1) {
                                    externals[name_4].push(imprt);
                                }
                            }
                        }
                    }
                }
                //Find each import to include
                for (var _d = 0, _e = imports[name_1]; _d < _e.length; _d++) {
                    var imprt = _e[_d];
                    //Prepare temp variables
                    var end = 0;
                    var count = 0;
                    var first = false;
                    var type = false;
                    var submodule = void 0;
                    //Export entire module
                    if (imprt === '*') {
                        //Find range of exports to extract and remove imports
                        submodule = '';
                        for (var _f = 0, _g = module_1.substring(module_1.indexOf('{') + 1).split('\n'); _f < _g.length; _f++) {
                            var line = _g[_f];
                            if (line.trim().substring(0, 6) !== 'import') {
                                submodule += line + '\n';
                            }
                        }
                        end = submodule.lastIndexOf('}');
                    }
                    //Check for start position of const
                    var checkConst = new RegExp('export(\\s|\\s.*\\s)(const|let|var|function)\\s' + imprt + '(|\\s|\\s.*\\s)({|:)').exec(module_1);
                    if (imprt !== '*' && checkConst) {
                        //Find range of import to extract
                        submodule = module_1.substring(checkConst.index);
                        end = submodule.indexOf('\n');
                    }
                    //Check for start position of import
                    var checkBraces = new RegExp('export(\\s|\\s.*\\s)(class|interface|enum)\\s' + imprt + '(|\\s|\\s.*\\s)({|:)').exec(module_1);
                    if (imprt !== '*' && checkBraces) {
                        //Find range of import to extract
                        submodule = module_1.substring(checkBraces.index);
                        for (var _h = 0, _j = esprima.tokenize(submodule, { range: true }); _h < _j.length; _h++) {
                            var token = _j[_h];
                            if (token.type === 'Punctuator' && token.value === '{') {
                                count += 1;
                                first = true;
                            }
                            if (token.type === 'Punctuator' && token.value === '}') {
                                count -= 1;
                            }
                            if (token.type === 'Punctuator' && token.value === '}' && count === 0 && first) {
                                end = token.range[1];
                                break;
                            }
                        }
                    }
                    //Extract and dump in new bundle
                    if (submodule) {
                        newBundle += submodule.substring(0, end) + '\n';
                    }
                }
            }
            console.log(imports);
            console.log(exports);
            //Remove externals which are not in use
            Object.keys(externals).forEach(function (name) {
                externals[name] = externals[name].filter(function (item) { return newBundle.indexOf(item) > -1; });
                //Remove if empty
                if (externals[name].length <= 0) {
                    delete externals[name];
                }
            });
            //Prepare externals header
            var header = '';
            Object.keys(externals).forEach(function (name) {
                header += 'import { ' + externals[name].join(', ') + ' } from "' + name + '" \n';
            });
            newBundle = header + newBundle;
            //Cleanup bundle formatting
            if (newBundle.length > 0) {
                newBundle = beautify(newBundle.replace(/^ +/gm, '').replace(/\n\n/gm, ''), { indent_size: 1, indent_with_tabs: true });
            }
            //Write new bundle to file
            _this.fs.writeFileSync(out, newBundle || ' ');
        });
    };
    DeclerationsPlugin.prototype.replace = function (start, end, what) {
        return what.substring(0, start) + Array(end - start).join(' ') + what.substring(end);
    };
    return DeclerationsPlugin;
}());
exports.DeclerationsPlugin = DeclerationsPlugin;
